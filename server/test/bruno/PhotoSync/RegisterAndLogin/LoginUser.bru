meta {
  name: LoginUser
  type: http
  seq: 3
}

post {
  url: {{HOST}}/login
  body: none
  auth: inherit
}

assert {
  res.status: eq 200
  res.headers["access-control-allow-origin"]: eq {{ALLOWED_ORIGIN}}
}

script:pre-request {
  var username = bru.getCollectionVar("USERNAME")
  var password = bru.getCollectionVar("PASSWORD")
  req.setBody(`{"username": "${username}", "password": "${password}"}`)
}

tests {
  function parseJwt (token) {
      var base64Url = token.split('.')[1];
      var base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
      var jsonPayload = decodeURIComponent(Buffer.from(base64, 'base64').toString('utf8').split('').map(function(c) {
          return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
      }).join(''));
      return JSON.parse(jsonPayload);
  }
  var expectedUsername = bru.getCollectionVar("USERNAME")
  
  var token = parseJwt(res.getBody())
  
  test('Check if jwt has correct username', () => {
  	expect(token).to.have.property('username');
  	expect(token.username).to.eql(expectedUsername);
  })
  test('Check if jwt has correct user_id', () => {
  	expect(token).to.have.property('user_id');
  	expect(token.user_id).to.eql("1");
  })
  test('Check if jwt has exipartion time set to one day from now', () => {
  	expect(token).to.have.property('expiration_time');
  	let roundedExpectedTime = (Date.now() / 1000) + 60 * 60 * 24
  	let oneMinuteErrorWindow = 60
  
  	if(Math.abs(roundedExpectedTime - token.expiration_time) > oneMinuteErrorWindow){
  		throw new Error("Expiration time differs too much from expected one!")
  	}
  })
  bru.setVar("TOKEN", res.getBody())
  
}
